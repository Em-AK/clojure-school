  #+Title: Clojure School
  #+Author: Likely
  #+Email: 

#+REVEAL_EXTRA_CSS: css/zenburn.css
#+REVEAL_THEME: solarized
#+OPTIONS: num:nil toc:nil reveal_mathjax:t
#+REVEAL_TRANS: fade

* Who is already a programmer?

* Experience of LISP?

* What text editor?

Emacs
Vim
Sublime
Textmate
Eclipse
IntelliJ
NetBeans

* Who has Java?

* Getting Set Up

First, you’ll need a Java Virtual Machine, or JVM, and its associated development tools, called the JDK. This is the software which runs a Clojure program. If you’re on Windows, install Oracle JDK 1.7. If you’re on OS X or Linux, you may already have a JDK installed. In a terminal, try:

#+BEGIN_SRC clojure
which javac
#+END_SRC

If you see something like

#+BEGIN_SRC clojure
/usr/bin/javac
#+END_SRC

Then you're good to go

Windows users: http://leiningen.org/#install

* Leiningen

#+BEGIN_SRC bash
mkdir -p ~/bin
cd ~/bin
curl -O https://raw.github.com/technomancy/leiningen/stable/bin/lein
chmod a+x lein
#+END_SRC

#+BEGIN_SRC bash
cd
lein new scratch
#+END_SRC

#+BEGIN_SRC bash
export PATH="$PATH":~/bin
#+END_SRC

* REPL

#+BEGIN_SRC bash
lein repl
#+END_SRC

This is an interactive Clojure environment called a REPL, for “Read, Evaluate, Print Loop”. It’s going to read a program we enter, run that program, and print the results. REPLs give you quick feedback, so they’re a great way to explore a program interactively, run tests, and prototype new ideas.

* REPL

With most languages, you write the system from the outside.

With LISPs, you bring the system up and develop it from the inside.

* Jumping inside

#+BEGIN_SRC clojure
user=> nil
nil
#+END_SRC

nil is the most basic value in Clojure. It represents the absence of information.

* Boolean values

#+BEGIN_SRC clojure
user=> true
true
user=> false
false
#+END_SRC

true and false are a pair of special values called Booleans. They mean exactly what you think: whether a statement is true or false. true, false, and nil form the three poles of the Lisp logical system.

* Basic Types

0
-42
1.2e-5
1/3
"Hi there!"
:keywords

* Collection Types

Maps
{:a 1 :b 2}

Sets
#{1 2 3}

Vectors
[1 2 3]

... that's it!

"It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures." —Alan Perlis

* Deffo

user=> (def x 3)
#'user/x

We've defined a var in the 'user' namespace and can refer to it:

user=> x
3

* Lists

#+BEGIN_SRC clojure
user=> (1 2 3)
ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/eval146 (NO_SOURCE_FILE:1)
#+END_SRC

* Wha happen?

The REPL sees a list and treats it as a function invocation.

The first element in the list is always the function to be invoked, with any remaining elements passed as arguments.

* Function Invocation

user=> (inc 0)
1

user=> (inc x)
4

* Nesting

Increment
  increment
    the number zero


user=> (inc (inc 0))
2

* Evaluation

Every list starts with a verb. Parts of a list are evaluated from left to right. Innermost lists are evaluated before outer lists.

(+ 1 (- 5 2) (+ 3 4))
(+ 1 3       (+ 3 4))
(+ 1 3       7)
11

* Having fn yet?

user=> (fn [x] (+ x 1))
#<user$eval149$fn__150 user$eval149$fn__150@397d812b>

We've created a function!


* Usage

user=> ((fn [x] (+ x 1)) 10)
11

You probably won't see this in production code...

* Defn

user=> (def half (fn [number] (/ number 2)))
#'user/half
user=> (half 6)
3
Creating a function and binding it to a var is so common that it has its own form: defn, short for def fn.

user=> (defn half [number] (/ number 2))
#'user/half

* Function Arity

Functions don’t have to take an argument. We’ve seen functions which take zero arguments, like (+).

user=> (defn half [] 1/2)
#'user/half
user=> (half)
1/2
But if we try to use our earlier form with one argument, Clojure complains that the arity–the number of arguments to the function–is incorrect.

user=> (half 10)

ArityException Wrong number of args (1) passed to: user$half  clojure.lang.AFn.throwArity (AFn.java:437)

* Multiple Arities

To handle multiple arities, functions have an alternate form. Instead of an argument vector and a body, one provides a series of lists, each of which starts with an argument vector, followed by the body.

user=> (defn half
         ([]  1/2)
         ([x] (/ x 2)))
user=> (half)
1/2
user=> (half 10)
5



* Variable Arities

Some functions can take any number of arguments. For that, Clojure provides &, which slurps up all remaining arguments as a list:

user=> (defn vargs
         [x y & more-args]
         {:x    x
          :y    y
          :more more-args})
#'user/vargs
user=> (vargs 1)

ArityException Wrong number of args (1) passed to: user$vargs  clojure.lang.AFn.throwArity (AFn.java:437)
user=> (vargs 1 2)
{:x 1, :y 2, :more nil}
user=> (vargs 1 2 3 4 5)
{:x 1, :y 2, :more (3 4 5)}


* Bindings

We know that symbols are names for things, and that when evaluated, Clojure replaces those symbols with their corresponding values. +, for instance, is a symbol which points to the verb #<core$_PLUS_ clojure.core$_PLUS_@12992c>.

user=> +
#<core$_PLUS_ clojure.core$_PLUS_@12992c>
When you try to use a symbol which has no defined meaning, Clojure refuses:

user=> cats

CompilerException java.lang.RuntimeException: Unable to resolve symbol: cats in this context, compiling:(NO_SOURCE_PATH:0:0)
But we can define a meaning for a symbol within a specific expression, using let.

user=> (let [cats 5] (str "I have " cats " cats."))
"I have 5 cats."

* Bindings are local

Let bindings apply only within the let expression itself. They also override any existing definitions for symbols at that point in the program. For instance, we can redefine addition to mean subtraction, for the duration of a let:

user=> (let [+ -] (+ 2 3))
-1
But that definition doesn’t apply outside the let:

user=> (+ 2 3)
5

* Bindings can be composed

We can also provide multiple bindings. Since Clojure doesn’t care about spacing, alignment, or newlines, I’ll write this on multiple lines for clarity.

user=> (let [person   "joseph"
             num-cats 186]
         (str person " has " num-cats " cats!"))
"joseph has 186 cats!"

When multiple bindings are given, they are evaluated in order. Later bindings can use previous bindings.

user=> (let [cats 3
             legs (* 4 cats)]
         (str legs " legs all together"))
"12 legs all together"

* Keywords as functions
* Destructuring

user=> (def my-map {:a 1 :b 2 :c [3 4 5]})
#'user/my-map

user=> (let [a (:a my-map)
             b (:b my-map)]
         (+ a b))
3

user=> (let [a (:a my-map)
             b (:b my-map)]
         (+ a b))
3

user=> (let [{a :a b :b} my-map]
         (+ a b))
3

user=> (let [{:keys [a b]} my-map]
         (+ a b))
3

user=> (let [{:keys [c]} my-map
             [c1 c2 c3] c]
         (+ c1 c2 c3))
12

user=> (let [{[c1 c2 c3] :c} my-map]
         (+ c1 c2 c3))
12

* Functions

We saw in chapter one that Clojure evaluates lists by substituting some other value in their place:

user=> (inc 1)
2
inc takes any number, and is replaced by that number plus one. That sounds an awful lot like a let:

user=> (let [x 1] (+ x 1))
2
If we bound x to 5 instead of 1, this expression would evaluate to 6. We can think about inc like a let expression, but without particular values provided for the symbols.

(let [x] (+ x 1))
We can’t actually evaluate this program, because there’s no value for x yet. It could be 1, or 4, or 1453. We say that x is unbound, because it has no binding to a particular value. This is the nature of the function: an expression with unbound symbols.

user=> (fn [x] (+ x 1))
#<user$eval293$fn__294 user$eval293$fn__294@663fc37>



* Higher order functions

Functions that accept or return functions

user=> (def names [{:forename "Henry" :surname "Garner"}
                   {:forename "James" :surname "Henderson"}])
#'user/names

user=> (defn full-name [{:keys [forename surname]}]
         (str forename " " surname))
#'user/full-name

user=> (full-name (first names))
"Henry Garner"

user=> (map full-name names)
["Henry Garner" "James Henderson"]

* Anonymous Functions

Used where you have a case for a single-use function that doesn't warrant a name.

user=> (def names [{:forename "Henry" :surname "Garner"}
                   {:forename "James" :surname "Henderson"}])
#'user/names

user=> (defn full-name [forename surname]
         (str forename " " surname))
#'user/full-name

user=> (map (fn [x] (full-name (:forename x) (:surname x))) names)

;; Equivalent to

user=> (map #(full-name (:forename %) (:surname %)) names)

* Anonymous function arities

You can refer to multiple args by %1, %2, ...

(fn [x y] (+ x y))

;; Equivalent to

#(+ %1 %2)

* The sequence core library


Simple

distinct
assoc
dissoc
first
second
nth
last
reverse
sort
keys
vals
get
conj cons concat interleave interpose
zipmap


Lazy

take
drop
partition partition-all
split-at
range

Higher Order

sort-by
map
mapcat
filter
remove
reduce
partition-by
group-by
take

* Namespaces

In the REPL we get a 'user' namespace. In larger projects we like to split our code out into more namespaces.

We can refer to symbols in other namespaces.

(ns some.namespace
  (:require [other.namespace :as blah]))


* Leiningen's project.clj

(defproject weather "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.5.1"]
                 [clj-http "0.7.7"]])

* Your code goes here

  src/weather/core.clj

Open up that file and remove the template function.

* Add dependencies

(ns weather.core
  (:require [clj-http.client :as http]))

* Let's use some real data

http://openweathermap.org/API

Free, JSON api that provides current weather data and forecasts.

* Sample questions

- How many cities called London are there? (hint: find?q=London)
- What are the lat/long positions of all the Londons?
- What has been the average temperature of London, UK for the last 5 days? (hint: forecast?q=London)
- What has been the average temperature of London, UK for the last 10 days?
- On how many of the last 10 days has it been cloudy?
- On how many of the last 10 days has it not been cloudy?


* Clojure the Parasite

Clojure is, by its very nature, a hosted language. 

Stable:

- Clojure (obviously!) - targets the JVM
- ClojureScript - compiles to JavaScript

On the way:

- Clojure.NET
- clojurescript-lua
- clojurec
- clojure-py
- clojure-scheme

* Accessing the host environment - Clojure &rarr; Java

  (let [date (new org.joda.DateTime 2013 11 12)]
    (.getDayOfWeek date))

  ;; or

  (let [date (org.joda.DateTime. 2013 11 12)]
    (. date (getDayOfWeek))

  (System/currentTimeMillis)

* With a spoonful of sugar

  ;; for date.withHourOfDay(12).withMinuteOfHour(53);

  ;; rather than

  (.withMinuteOfHour (.withHourOfDay date 12) 53)

  ;; we can write

  (.. date (withHourOfDay 12) (withMinuteOfHour 53))

* Recycling with 'doto'

  (let [my-obj (.. (doto (MyObjectBuilder.)  
                     (.setValue 8) 
                     (.setString "Hello!")
                     (.setOtherThing (+ 145.2 13.25)))
                   (build))]
    my-obj)

  ;; equivalent to:

  MyObjectBuilder builder = new MyObjectBuilder();
  builder.setValue(8);
  builder.setString("Hello!");
  builder.setOtherThing(145.2 + 13.25);
  MyObject myObj = builder.build();

* Importing the goods

(ns your-ns
  (:require [your-clj.namespace :refer [your-fn]])
  (:import [java.util UUID Date Random Currency]
           [org.joda.time DateTime Period Interval]))

* Implementing Java interfaces

  (.addActionListener button
                      (reify ActionListener
                        (actionPerformed [this e]
                          (prn "Got action:" e))))
