#+Title: Clojure School
#+Author: Likely
#+Email: 

#+REVEAL_EXTRA_CSS: css/zenburn.css
#+REVEAL_THEME: moon
#+OPTIONS: num:nil toc:nil reveal_mathjax:t history:t
#+REVEAL_TRANS: fade

* One I prepared earlier

  git://github.com/likely/sketchy.git

* A quick refresher

  - Requests and responses are just maps
  - Handlers are functions for turning requests into responses
  - Atoms allow state to be mutated with pure functions
  - Changes are atomic and thread safe
  - We proved this by starting threads with future

* Today's lesson

  - How does defroutes help turn requests into responses?
  - What are other ways of dealing with concurrency?
  - Can we use these ideas to make an interactive, multi-person app?

* We'll be covering
  
  - Macros
  - core.async
  - ClojureScript

* Caveat: these are big topics!

We could easily spend a day on each one.

We'll give you an understanding of the basics, and hopefully the hunger to find out more.

* Macros

A macro is just a function that receives its arguments *unevaluated* at compile time.

Because the unevaluated arguments are *code*, macros can operate on the code as if it was data*.

* Macros we've already used

Compojure's `defroutes` is a macro.

We can use `macroexpand` to inspect it.

* Macroexpand

You can use the function macroexpand and macroexpand-all to see the effect of macros.

#+BEGIN_SRC clojure
(macroexpand-all '(defroutes app-routes
  (GET "/" [] (index-view (swap! counter inc)))
  (GET "/ws" [] socket-handler)
  (route/resources "/")
  (route/not-found "Not Found")))
#+END_SRC

* Why are Macros? 

If *functions* receive data and return new data,

Macros receive *code* and return *new code*.
  
* Argument evaluation
  
#+BEGIN_SRC clojure
(and (= 1 1) (println "Hello World"))
#+END_SRC

Is "Hello World" printed?

#+BEGIN_SRC clojure
(and (= 1 0) (println "Hello World"))
#+END_SRC

Why?


* Exercise

  What does the following expand to?

  #+BEGIN_SRC clojure
  (and (= 1 0) (println "Hello World"))
  #+END_SRC
  
* Other macros in Clojure.core

  and, or, when, while, for, cond, ->, ->>

  -> and ->> are the threading macros, they restructure code to make it more legible.
 
* Exercise

  Re-write the view using threading

  #+BEGIN_SRC clojure
  (index-view (swap! counter inc))
  #+END_SRC

* Exercise

#+begin_src clojure

;; Re-write the below using -> threading macro
(/ (* (+ 10 2) 5) (* 2 5))

  
;; Re-write the below using ->> threading macro
(* 10 (apply + (map inc (range 10))))
#+end_src

* Macro magic: core.async

An implementation of Communicating Sequential Processes (CSP).

CSP is an old idea, but basis of concurrency in languages such as Google's Go.

The processes are more lightweight than threads, suitable for parallel web apps.

* Core Async
  
  Inside a go block you can do what appear to be async synchronously.
  
  #+BEGIN_SRC clojure
  (go 5)
=> #<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@30804b08>
  #+END_SRC
  
  Take accepts a channel and returns a value from it. It needs to be inside a go block.

  #+BEGIN_SRC clojure
  user> (go (println (<! (go 5))))
#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@5636e34>
5
  #+END_SRC

  See also: >!

* Synchronous
  
  The semantics of CSP are that takes and puts are synchronous.
  If you take, it will block until something puts.
  It you put, it will block until something takes.
  #+BEGIN_SRC clojure
    (let [c (chan)]
      (go
       (println "We are here")
       (<! c)
       (println "We won't get here")))
  #+END_SRC

* Channels

  Channels allow goroutines to talk to each other.
  
  #+BEGIN_SRC clojure
  ;; Order doesn't matter
        (let [c (chan)]
          (go
           (>! c "A message"))
          (go
           (println "We are here")
           (<! c)
           (println "We made progress")))
    
        We are here
    #<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@27d198c3>
    We made progress  
  #+END_SRC

* Websockets
  
  Websockets are long-lived connections between the client and the server through which messages can be sent in both directions.

* Creating a channel from a websocket

  Uncomment includes at the top of the handler

  #+BEGIN_SRC clojure
  (defn socket-handler [request]
  (with-channel request ws-ch
    (go-loop []
      (let [{:keys [message]} (<! ws-ch)]
        (>! ws-ch message)
        (recur)))))
  #+END_SRC

* In your browser's js console...

#+begin_src js
var socket = new WebSocket("ws://localhost:3000/ws");

socket.onmessage = function(event) { console.log(event.data); }

socket.send("Data to be sent");
#+end_src

You should see the data you sent echoed back.

* ClojureScript

You can write client-side javascript in Clojure too!

* Writing Clojurescript

Create the file

/src/cljs/sketchy/client.cljs

#+begin_src clojure
(ns sketchy.client)

(defn greet [name]
  (str "Hello " name))
#+end_src

* Include this in our page

#+begin_src clojure
(html5
   [:head
    (include-js "js/sketchy.js")]
   [:body ....
   ])
#+end_src

* Reload the page

And in your console, type

#+begin_src js
chitter.client.greet("World");

=> "Hello World"
#+end_src

* Javascript Interop

Property access

#+BEGIN_SRC clojure
;; obj.x becomes:

(.-x obj)
#+END_SRC

Calling functions

#+BEGIN_SRC clojure
;; obj.call(something);

(.call obj something)
#+END_SRC

Access global javascript object

#+BEGIN_SRC clojure
;; console.log("message") becomes:

(js/console.log "message")
#+END_SRC

* Exercise

Create an event handler in ClojureScript that will print out the mouse coordinates.

#+BEGIN_SRC js
// In javascript this would be
window.addEventListener("mousemove",
  function(event) { 
    console.log(event);
  });
#+END_SRC

* Load javascript on page load

Add to bottom of ClojureScript:

#+begin_src clojure
(set! (.-onload js/window) main)
#+end_src

We're calling a function called 'main' on page load.

* Creating UI channel

#+BEGIN_SRC clojure
  (defn events [el type]
    (let [out (chan)]
      (d/listen! el type
                 (fn [e] (put! out e)))
      out))
#+END_SRC

We're outside a go block so we can't use >!. We use the asynchronous version put!

* Exercise

Inside your main function, create a go loop that prints out the mousemoved events

* Channels are like sequences

They have map and reduce too!

#+BEGIN_SRC clojure
;; Takes a function and a source channel, and returns a channel which
;; contains the values produced by applying f to each value taken from
;; the source channel
(map< some-fn some-channel)
#+END_SRC

See also map>, reduce, filter>, filter<, remove>, remove<

* Exercise

Adapt your main function to print out a vector containing only the x and y components of the mousemove event.

* Drawing into the canvas


#+BEGIN_SRC clojure
(defn draw-point [canvas [x y]]
  (let [context (.getContext canvas "2d")]
    (.fillRect context x y 10 10)))
#+END_SRC

* Skip to the end

Combing channels with alts!

loop recur

condp

#+BEGIN_SRC 

(defn main []
  (let [canvas (sel1 :#canvas)
        move (map< e->v (events canvas "mousemove"))
        down (events canvas "mousedown")
        up (events canvas "mouseup")]
    (go
     (let [ws (<! (ws-ch "ws://localhost:3000/ws"))]
       (go-loop []
                (draw-point canvas (read-string (:message (<! ws))))
                (recur))
       (go-loop [draw-point? false]
                (let [[v sc] (alts! [move down up])]
                  (condp = sc
                    down (recur true)
                    up (recur false)
                    move (do (when draw-point?
                               (js/console.log (pr-str v))
                               (>! ws v))
                             (recur draw-point?)))))))))
#+END_SRC

* Create a collaborative drawing app!

Adapt the server side keep an atom of clients, return events to all of them.

* What we covered

- Macros
- core.async
- ClojureScript

* Thank You
