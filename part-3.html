<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>(Clojure School)</title>
<meta name="author" content="(Likely)"/>
<link rel="stylesheet" href="./reveal.js/css/reveal.min.css"/>
<link rel="stylesheet" href="./reveal.js/css/theme/moon.css" id="theme"/>
<link rel="stylesheet" href="css/zenburn.css"/>
<link rel="stylesheet" href="./reveal.js/css/print/pdf.css" type="text/css" media="print"/>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section>
<h1>Clojure School</h1>
<h2>Likely</h2>
<h2><a href="mailto:"></a></h2>
<h2></h2></section>

<section>
<section id="sec-1" >

<h2>One I prepared earlier</h2>
<p>
git://github.com/likely/sketchy.git
</p>
</section>
</section>
<section>
<section id="sec-2" >

<h2>A quick refresher</h2>
<ul class="org-ul">
<li>Requests and responses are just maps
</li>
<li>Handlers are functions for turning requests into responses
</li>
<li>Atoms allow state to be mutated with pure functions
</li>
<li>Changes are atomic and thread safe
</li>
<li>We proved this by starting threads with future
</li>
</ul>
</section>
</section>
<section>
<section id="sec-3" >

<h2>Today's lesson</h2>
<ul class="org-ul">
<li>How does defroutes help turn requests into responses?
</li>
<li>What are other ways of dealing with concurrency?
</li>
<li>Can we use these ideas to make an interactive, multi-person app?
</li>
</ul>
</section>
</section>
<section>
<section id="sec-4" >

<h2>We'll be covering</h2>
<ul class="org-ul">
<li>Macros
</li>
<li>core.async
</li>
<li>ClojureScript
</li>
</ul>
</section>
</section>
<section>
<section id="sec-5" >

<h2>Caveat: these are big topics!</h2>
<p>
We could easily spend a day on each one.
</p>

<p>
We'll give you an understanding of the basics, and hopefully the hunger to find out more.
</p>
</section>
</section>
<section>
<section id="sec-6" >

<h2>Macros</h2>
<p>
A macro is just a function that receives its arguments <b>unevaluated</b> at compile time.
</p>

<p>
Because the unevaluated arguments are <b>code</b>, macros can operate on the code as if it was data*.
</p>
</section>
</section>
<section>
<section id="sec-7" >

<h2>Macros we've already used</h2>
<p>
Compojure's `defroutes` is a macro.
</p>

<p>
We can use `macroexpand` to inspect it.
</p>
</section>
</section>
<section>
<section id="sec-8" >

<h2>Macroexpand</h2>
<p>
You can use the function macroexpand and macroexpand-all to see the effect of macros.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #00ff00;">macroexpand-all</span> '(<span style="color: #00ffff; font-weight: bold;">defroutes</span> <span style="color: #0000ff; font-weight: bold;">app-routes</span>
  (<span style="color: #0000ff; font-weight: bold;">GET</span> <span style="color: #00ff00;">"/"</span> [] (index-view (<span style="color: #0000ff; font-weight: bold;">swap!</span> counter inc)))
  (<span style="color: #0000ff; font-weight: bold;">GET</span> <span style="color: #00ff00;">"/ws"</span> [] socket-handler)
  (route/resources <span style="color: #00ff00;">"/"</span>)
  (route/not-found <span style="color: #00ff00;">"Not Found"</span>)))
</pre>
</div>
</section>
</section>
<section>
<section id="sec-9" >

<h2>Why are Macros?</h2>
<p>
If <b>functions</b> receive data and return new data,
</p>

<p>
Macros receive <b>code</b> and return <b>new code</b>.
</p>
</section>
</section>
<section>
<section id="sec-10" >

<h2>Argument evaluation</h2>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #00ffff; font-weight: bold;">and</span> (<span style="color: #0000ff; font-weight: bold;">=</span> 1 1) (<span style="color: #0000ff; font-weight: bold;">println</span> <span style="color: #00ff00;">"Hello World"</span>))
</pre>
</div>

<p>
Is "Hello World" printed?
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #00ffff; font-weight: bold;">and</span> (<span style="color: #0000ff; font-weight: bold;">=</span> 1 0) (<span style="color: #0000ff; font-weight: bold;">println</span> <span style="color: #00ff00;">"Hello World"</span>))
</pre>
</div>

<p>
Why?
</p>
</section>

</section>
<section>
<section id="sec-11" >

<h2>Exercise</h2>
<p>
What does the following expand to?
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #00ffff; font-weight: bold;">and</span> (<span style="color: #0000ff; font-weight: bold;">=</span> 1 0) (<span style="color: #0000ff; font-weight: bold;">println</span> <span style="color: #00ff00;">"Hello World"</span>))
</pre>
</div>
</section>
</section>
<section>
<section id="sec-12" >

<h2>Other macros in Clojure.core</h2>
<p>
and, or, when, while, for, cond, -&gt;, -&gt;&gt;
</p>

<p>
-&gt; and -&gt;&gt; are the threading macros, they restructure code to make it more legible.
</p>
</section>
</section>
<section>
<section id="sec-13" >

<h2>Exercise</h2>
<p>
Re-write the view using threading
</p>

<div class="org-src-container">

<pre class="src src-clojure">(index-view (<span style="color: #0000ff; font-weight: bold;">swap!</span> counter inc))
</pre>
</div>
</section>
</section>
<section>
<section id="sec-14" >

<h2>Exercise</h2>
<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #ff0000;">;; </span><span style="color: #ff0000;">Re-write the below using -&gt; threading macro</span>
(<span style="color: #0000ff; font-weight: bold;">/</span> (<span style="color: #0000ff; font-weight: bold;">*</span> (<span style="color: #0000ff; font-weight: bold;">+</span> 10 2) 5) (<span style="color: #0000ff; font-weight: bold;">*</span> 2 5))


<span style="color: #ff0000;">;; </span><span style="color: #ff0000;">Re-write the below using -&gt;&gt; threading macro</span>
(<span style="color: #0000ff; font-weight: bold;">*</span> 10 (<span style="color: #0000ff; font-weight: bold;">apply</span> + (<span style="color: #0000ff; font-weight: bold;">map</span> inc (<span style="color: #0000ff; font-weight: bold;">range</span> 10))))
</pre>
</div>
</section>
</section>
<section>
<section id="sec-15" >

<h2>Macro magic: core.async</h2>
<p>
An implementation of Communicating Sequential Processes (CSP).
</p>

<p>
CSP is an old idea, but basis of concurrency in languages such as Google's Go.
</p>

<p>
The processes are more lightweight than threads, suitable for parallel web apps.
</p>
</section>
</section>
<section>
<section id="sec-16" >

<h2>Core Async</h2>
<p>
Inside a go block you can do what appear to be async synchronously.
</p>

<div class="org-src-container">

<pre class="src src-clojure">  (go 5)
=&gt; #&lt;<span style="color: #0000ff; font-weight: bold;">ManyToManyChannel</span> clojure.core.async.impl.channels.ManyToManyChannel@30804b08&gt;
</pre>
</div>

<p>
Take accepts a channel and returns a value from it. It needs to be inside a go block.
</p>

<div class="org-src-container">

<pre class="src src-clojure">  user&gt; (go (<span style="color: #0000ff; font-weight: bold;">println</span> (&lt;! (go 5))))
#&lt;<span style="color: #0000ff; font-weight: bold;">ManyToManyChannel</span> clojure.core.async.impl.channels.ManyToManyChannel@5636e34&gt;
5
</pre>
</div>

<p>
See also: &gt;!
</p>
</section>
</section>
<section>
<section id="sec-17" >

<h2>Synchronous</h2>
<p>
The semantics of CSP are that takes and puts are synchronous.
If you take, it will block until something puts.
It you put, it will block until something takes.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #00ffff; font-weight: bold;">let</span> [c (chan)]
  (go
   (<span style="color: #0000ff; font-weight: bold;">println</span> <span style="color: #00ff00;">"We are here"</span>)
   (&lt;! c)
   (<span style="color: #0000ff; font-weight: bold;">println</span> <span style="color: #00ff00;">"We won't get here"</span>)))
</pre>
</div>
</section>
</section>
<section>
<section id="sec-18" >

<h2>Channels</h2>
<p>
Channels allow goroutines to talk to each other.
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #ff0000;">;; </span><span style="color: #ff0000;">Order doesn't matter</span>
      (<span style="color: #00ffff; font-weight: bold;">let</span> [c (chan)]
        (go
         (&gt;! c <span style="color: #00ff00;">"A message"</span>))
        (go
         (<span style="color: #0000ff; font-weight: bold;">println</span> <span style="color: #00ff00;">"We are here"</span>)
         (&lt;! c)
         (<span style="color: #0000ff; font-weight: bold;">println</span> <span style="color: #00ff00;">"We made progress"</span>)))

      <span style="color: #0000ff; font-weight: bold;">We</span> are here
  #&lt;<span style="color: #0000ff; font-weight: bold;">ManyToManyChannel</span> clojure.core.async.impl.channels.ManyToManyChannel@27d198c3&gt;
  <span style="color: #0000ff; font-weight: bold;">We</span> made progress
</pre>
</div>
</section>
</section>
<section>
<section id="sec-19" >

<h2>Websockets</h2>
<p>
Websockets are long-lived connections between the client and the server through which messages can be sent in both directions.
</p>
</section>
</section>
<section>
<section id="sec-20" >

<h2>Creating a channel from a websocket</h2>
<p>
Uncomment includes at the top of the handler
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #00ffff; font-weight: bold;">defn</span> <span style="color: #0000ff; font-weight: bold;">socket-handler</span> [request]
(with-channel request ws-ch
  (go-loop []
    (<span style="color: #00ffff; font-weight: bold;">let</span> [{<span style="color: #ff00ff;">:keys</span> [message]} (&lt;! ws-ch)]
      (&gt;! ws-ch message)
      (<span style="color: #00ffff; font-weight: bold;">recur</span>)))))
</pre>
</div>
</section>
</section>
<section>
<section id="sec-21" >

<h2>In your browser's js console&#x2026;</h2>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #00ffff; font-weight: bold;">var</span> <span style="color: #ffff00;">socket</span> = <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">WebSocket</span>(<span style="color: #00ff00;">"ws://localhost:3000/ws"</span>);

socket.onmessage = <span style="color: #00ffff; font-weight: bold;">function</span>(<span style="color: #ffff00;">event</span>) { console.log(event.data); }

socket.send(<span style="color: #00ff00;">"Data to be sent"</span>);
</pre>
</div>

<p>
You should see the data you sent echoed back.
</p>
</section>
</section>
<section>
<section id="sec-22" >

<h2>ClojureScript</h2>
<p>
You can write client-side javascript in Clojure too!
</p>
</section>
</section>
<section>
<section id="sec-23" >

<h2>Writing Clojurescript</h2>
<p>
Create the file
</p>

<p>
/src/cljs/sketchy/client.cljs
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #00ffff; font-weight: bold;">ns</span> sketchy.client)

(<span style="color: #00ffff; font-weight: bold;">defn</span> <span style="color: #0000ff; font-weight: bold;">greet</span> [name]
  (<span style="color: #0000ff; font-weight: bold;">str</span> <span style="color: #00ff00;">"Hello "</span> name))
</pre>
</div>
</section>
</section>
<section>
<section id="sec-24" >

<h2>Include this in our page</h2>
<div class="org-src-container">

<pre class="src src-clojure">(html5
   [<span style="color: #ff00ff;">:head</span>
    (include-js <span style="color: #00ff00;">"js/sketchy.js"</span>)]
   [<span style="color: #ff00ff;">:body</span> ....
   ])
</pre>
</div>
</section>
</section>
<section>
<section id="sec-25" >

<h2>Reload the page</h2>
<p>
And in your console, type
</p>

<div class="org-src-container">

<pre class="src src-js">chitter.client.greet(<span style="color: #00ff00;">"World"</span>);

=&gt; <span style="color: #00ff00;">"Hello World"</span>
</pre>
</div>
</section>
</section>
<section>
<section id="sec-26" >

<h2>Javascript Interop</h2>
<p>
Property access
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #ff0000;">;; </span><span style="color: #ff0000;">obj.x becomes:</span>

(<span style="color: #0000ff; font-weight: bold;">.-x</span> obj)
</pre>
</div>

<p>
Calling functions
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #ff0000;">;; </span><span style="color: #ff0000;">obj.call(something);</span>

(<span style="color: #0000ff; font-weight: bold;">.call</span> obj something)
</pre>
</div>

<p>
Access global javascript object
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #ff0000;">;; </span><span style="color: #ff0000;">console.log("message") becomes:</span>

(js/console.log <span style="color: #00ff00;">"message"</span>)
</pre>
</div>
</section>
</section>
<section>
<section id="sec-27" >

<h2>Exercise</h2>
<p>
Create an event handler in ClojureScript that will print out the mouse coordinates.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #ff0000;">// </span><span style="color: #ff0000;">In javascript this would be</span>
window.addEventListener(<span style="color: #00ff00;">"mousemove"</span>,
  <span style="color: #00ffff; font-weight: bold;">function</span>(<span style="color: #ffff00;">event</span>) { 
    console.log(event);
  });
</pre>
</div>
</section>
</section>
<section>
<section id="sec-28" >

<h2>Load javascript on page load</h2>
<p>
Add to bottom of page:
</p>

<div class="org-src-container">

<pre class="src src-clojure">[<span style="color: #ff00ff;">:script</span> <span style="color: #00ff00;">"sketchy.client.main()"</span>]
</pre>
</div>

<p>
We're calling a function called 'main' on page load.
</p>
</section>
</section>
<section>
<section id="sec-29" >

<h2>Creating UI channel</h2>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #00ffff; font-weight: bold;">defn</span> <span style="color: #0000ff; font-weight: bold;">events</span> [el type]
  (<span style="color: #00ffff; font-weight: bold;">let</span> [out (chan)]
    (<span style="color: #0000ff; font-weight: bold;">.addEventListener</span> el type
                       (<span style="color: #00ffff; font-weight: bold;">fn</span> [e] (put! out e)))
    out))
</pre>
</div>

<p>
We're outside a go block so we can't use &gt;!. We use the asynchronous version.
</p>
</section>
</section>
<section>
<section id="sec-30" >

<h2>Exercise</h2>
<p>
Inside your main function, create a go loop that prints out the mouse moved events
</p>
</section>
</section>
<section>
<section id="sec-31" >

<h2>Channels are like sequences</h2>
<p>
They have map and reduce too!
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #ff0000;">;; </span><span style="color: #ff0000;">Takes a function and a source channel, and returns a channel which</span>
<span style="color: #ff0000;">;; </span><span style="color: #ff0000;">contains the values produced by applying f to each value taken from</span>
<span style="color: #ff0000;">;; </span><span style="color: #ff0000;">the source channel</span>
(map&lt; some-fn some-channel)
</pre>
</div>

<p>
See also map&gt;, reduce, filter&gt;, filter&lt;, remove&gt;, remove&lt;
</p>
</section>
</section>
<section>
<section id="sec-32" >

<h2>Exercise</h2>
<p>
Adapt your main function to print out a vector containing only the pageX and pageY components of the mouse event.
</p>
</section>
</section>
<section>
<section id="sec-33" >

<h2>Drawing into the canvas</h2>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #00ffff; font-weight: bold;">defn</span> <span style="color: #0000ff; font-weight: bold;">draw-point</span> [context [x y]]
  (<span style="color: #0000ff; font-weight: bold;">.fillRect</span> context x y 10 10))
</pre>
</div>
</section>
</section>
<section>
<section id="sec-34" >

<h2>Skip to the end</h2>
<p>
Combing channels with alts!
</p>

<pre class="example">
(defn main []
  (let [move (map&lt; e-&gt;v (events js/window "mousemove"))
        down (events js/window "mousedown")
        up (events js/window "mouseup")
        canvas (sel1 :#canvas)
        context (.getContext canvas "2d")]
    (go
     (let [ws (&lt;! (ws-ch "ws://localhost:3000/ws"))]
       (go (while true
             (draw-point context (read-string (:message (&lt;! ws))))))
       (go-loop [draw-point? false]
                (let [[v sc] (alts! [move down up])]
                  (condp = sc
                    down (recur true)
                    up (recur false)
                    move (do (when draw-point?
                               (.log js/console (pr-str v))
                               (&gt;! ws v))
                             (recur draw-point?)))))))))
</pre>
</section>
</section>
<section>
<section id="sec-35" >

<h2>Create a collaborative drawing app!</h2>
<p>
Adapt the server side keep an atom of clients, return events to all of them.
</p>
</section>
</section>
<section>
<section id="sec-36" >

<h2>What we covered</h2>
<ul class="org-ul">
<li>Macros
</li>
<li>core.async
</li>
<li>ClojureScript
</li>
</ul>
</section>
</section>
<section>
<section id="sec-37" >

<h2>Thank You</h2>
<p>
/
</p>
</section>
</section>
</div>
</div>
<script src="./reveal.js/lib/js/head.min.js"></script>
<script src="./reveal.js/js/reveal.min.js"></script>
<script>

        		// Full list of configuration options available here:
        		// https://github.com/hakimel/reveal.js#configuration
        		Reveal.initialize({
        			controls: true,
        			progress: true,
        			history: false,
        			center: true,
        			rollingLinks: false,
        			keyboard: true,
        			overview: true,
        			 // slide width
        			 // slide height
        			 // slide margin
        			 // slide minimum scaling factor
        			 // slide maximum scaling factor


        			theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        			transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none
        			transitionSpeed: 'default',

        			// Optional libraries used to extend on reveal.js
        			dependencies: [
        				{ src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } }
        				,{ src: './reveal.js/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } }
        				,{ src: './reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } }
        				,{ src: './reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        				,{ src: './reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }
        				,{ src: './reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        				// { src: './reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
        				// { src: './reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
         				
        			]
        		});
</script>
</body>
</html>
